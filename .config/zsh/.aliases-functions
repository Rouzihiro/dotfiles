normalize() {
  ffmpeg -i "$1" -af loudnorm=I=-14:TP=-1.0:LRA=11 -c:v copy -c:a aac -b:a 192k output.mp4
}

ali() {
  local filter="$1"
  local filter_lc filter_name filter_value

  filter_lc=$(echo "$filter" | command tr '[:upper:]' '[:lower:]')

  # Your color escape sequence
  local COLOR_ESC="\033[38;2;127;180;202m"
  local RESET_ESC="\033[0m"

  # Header with your color
  echo -e "\n${COLOR_ESC}───────────[ Your Aliases ]───────────${RESET_ESC}\n"

  alias | grep -E "^[a-zA-Z_][a-zA-Z0-9_-]*=" | grep -v "^showalias=" | grep -v "git" | while IFS= read -r line; do
    local name="${line%%=*}"
    local value="${line#*=}"
    value="${value#\'}"
    value="${value%\'}"

    filter_name=$(echo "$name" | command tr '[:upper:]' '[:lower:]')
    filter_value=$(echo "$value" | command tr '[:upper:]' '[:lower:]')

    if [[ -n "$filter" && "$filter_name" != *"$filter_lc"* && "$filter_value" != *"$filter_lc"* ]]; then
      continue
    fi

    # Print alias name and value using your color for name and maybe lighter gray for value
    printf " ${COLOR_ESC}%-20s${RESET_ESC} → \033[0;37m%s\033[0m\n" "$name" "$value"
  done | sort

  echo -e "\n${COLOR_ESC}──────────────────────────────────────${RESET_ESC}\n"
}

# Extract any archive type
ex() {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *.xz)        unxz $1        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Quick note taking
note() {
    echo "$*" >> ~/Documents/Notes/coding.md
    echo "Note added: $*"
}


# View notes
notes() {
    if [ -f ~/Documents/Notes/coding.md ]; then
        if command -v bat >/dev/null 2>&1; then
            bat ~/Documents/Notes/coding.md
        else
            cat ~/Documents/Notes/coding.md
        fi
    else
        echo "No notes file found"
    fi
}

noter() {
    local file=~/Documents/Notes/coding.md
    [[ -f $file ]] || { echo "No notes file found"; return 1; }

    if command -v bat >/dev/null 2>&1; then
        bat -n --paging=never "$file"
    else
        cat -n "$file"
    fi

    echo -n "Enter line number to delete (or leave empty to cancel): "
    read lineno

    [[ $lineno =~ ^[0-9]+$ ]] || { echo "Cancelled"; return 1; }

    sed -i "${lineno}d" "$file"
    echo "Deleted line $lineno."
}

# Search history more efficiently  
hg() {
    history | grep "$1"
}

# Find and kill process by name
tko() {
    ps aux | grep "$1" | grep -v grep | awk '{print $2}' | xargs kill -9
}

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Show directory size sorted
dirsize() {
    du -sh */ 2>/dev/null | sort -hr
}

# Quick file search
ff() {
    find . -type f -name "*$1*" 2>/dev/null
}

# Quick directory search  
fd() {
    find . -type d -name "*$1*" 2>/dev/null
}

fs() {
  find . -type f -exec grep --color=always --binary-files=without-match "$1" {} +
}

fzv() {
  while file=$(fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}'); do
    nvim "$file"
  done
}
bindkey -s '^F' 'fzv\n'

open() {
  xdg-open "$@" >/dev/null 2>&1 &
}

keytest() {
    xev | grep -A2 --line-buffered '^KeyRelease' | sed -n '/keycode /s/^.*keycode \([0-9]*\).* (.*, \(.*\)).*$/\1 \2/p'
}
