command -v nvim > /dev/null 2>&1 && export MANPAGER="nvim +Man!"

ls-man () {
    entry_raw="$(man -k . | fzf --exact --style=full)" || return 1
    manpage_name="$(echo "$entry_raw" | cut -f1 -d ' ')"
    manpage_select="$(echo "$entry_raw" | cut -f2 -d ' ' | sed 's/^(//;s/)$//')"
    man "${manpage_select}" "${manpage_name}" || return 1
}


# Restart a program.
refresh () {
	killall $1
	$1 &
}

ls-monitor () {
wlr-randr | grep -o '^[^ ]*'
}


# Print out all the color IDs.
all-the-colors () {
    for i in $(seq 30 37); do
        echo -e "\033[1;${i}m${i}:\033[0m \033[0;${i}m(^-^)\033[0m"
    done
}

# Why such a long command for something so simple!?
alias get-framerate='ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1'

# Uptime Timer
alias uptick='clear; while [[ 1 == 1 ]]; do echo -en "\r$(uptime -p)\033[A"; done'

# Check To See If System Is BIOS Or UEFI
alias bios-or-uefi='[[ -d /sys/firmware/efi ]] && echo "UEFI" || echo "BIOS"'

alias ko-steam='while [[ 1 == 1 ]]; do killall steam; pkill steam; done'

# Fancy select screen.
fancy-select () {
    prompt_desc="$1"

    fzf --color=16 --border=none --margin=0,0,0,0 --style=full:rounded --tac --ghost="$prompt_desc" || return 1
}

# File selection
alias zcat='bat "$(find . -type f | fancy-select "Open file:" | sed "s/\x1b\[[0-9;]*m//g")"'
alias zbat='bat "$(find . -type f | fancy-select "Open file:" | sed "s/\x1b\[[0-9;]*m//g")"'

# Directory navigation  
alias zz='cd "$(find . -type d | fancy-select "Go to directory:")"'

# Process management
alias zko='ps aux | fancy-select "Kill process:" | awk "{print \$2}" | xargs kill'

normalize() {
  ffmpeg -i "$1" -af loudnorm=I=-14:TP=-1.0:LRA=11 -c:v copy -c:a aac -b:a 192k output.mp4
}

ali() {
  local filter="$1"
  local filter_lc filter_name filter_value

  filter_lc=$(echo "$filter" | command tr '[:upper:]' '[:lower:]')

  # Your color escape sequence
  local COLOR_ESC="\033[38;2;127;180;202m"
  local RESET_ESC="\033[0m"

  # Header with your color
  echo -e "\n${COLOR_ESC}───────────[ Your Aliases ]───────────${RESET_ESC}\n"

  alias | grep -E "^[a-zA-Z_][a-zA-Z0-9_-]*=" | grep -v "^showalias=" | grep -v "git" | while IFS= read -r line; do
    local name="${line%%=*}"
    local value="${line#*=}"
    value="${value#\'}"
    value="${value%\'}"

    filter_name=$(echo "$name" | command tr '[:upper:]' '[:lower:]')
    filter_value=$(echo "$value" | command tr '[:upper:]' '[:lower:]')

    if [[ -n "$filter" && "$filter_name" != *"$filter_lc"* && "$filter_value" != *"$filter_lc"* ]]; then
      continue
    fi

    # Print alias name and value using your color for name and maybe lighter gray for value
    printf " ${COLOR_ESC}%-20s${RESET_ESC} → \033[0;37m%s\033[0m\n" "$name" "$value"
  done | sort

  echo -e "\n${COLOR_ESC}──────────────────────────────────────${RESET_ESC}\n"
}

# Extract any archive type
ex() {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *.xz)        unxz $1        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Quick note taking
note() {
    echo "$*" >> ~/Documents/Notes/coding.md
    echo "Note added: $*"
}


# View notes
notes() {
    if [ -f ~/Documents/Notes/coding.md ]; then
        if command -v bat >/dev/null 2>&1; then
            bat ~/Documents/Notes/coding.md
        else
            cat ~/Documents/Notes/coding.md
        fi
    else
        echo "No notes file found"
    fi
}

noter() {
    local file=~/Documents/Notes/coding.md
    [[ -f $file ]] || { echo "No notes file found"; return 1; }

    if command -v bat >/dev/null 2>&1; then
        bat -n --paging=never "$file"
    else
        cat -n "$file"
    fi

    echo -n "Enter line number to delete (or leave empty to cancel): "
    read lineno

    [[ $lineno =~ ^[0-9]+$ ]] || { echo "Cancelled"; return 1; }

    sed -i "${lineno}d" "$file"
    echo "Deleted line $lineno."
}

# Search history more efficiently  
hg() {
    history | grep "$1"
}

# Find and kill process by name
tko() {
    ps aux | grep "$1" | grep -v grep | awk '{print $2}' | xargs kill -9
}

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Show directory size sorted
dirsize() {
    du -sh */ 2>/dev/null | sort -hr
}

# Quick file search
ff() {
    find . -type f -iname "*$1*" 2>/dev/null
}

# Quick directory search  
fd() {
    find . -type d -iname "*$1*" 2>/dev/null
}

fs() {
  find . -type f -exec grep --color=always --binary-files=without-match "$1" {} +
}

# fzv function
fzv() {
    while file=$(fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}'); do
        [ -n "$file" ] && nvim "$file"
    done
}
if [[ $- == *i* ]]; then
    if [ -n "$BASH_VERSION" ]; then
        # Ctrl+F → fzv
        bind -x '"\C-f": fzv'
    elif [ -n "$ZSH_VERSION" ]; then
        bindkey -s '^F' 'fzv\n'
    fi
fi

open() {
  xdg-open "$@" >/dev/null 2>&1 &
}

keytest() {
    xev | grep -A2 --line-buffered '^KeyRelease' | sed -n '/keycode /s/^.*keycode \([0-9]*\).* (.*, \(.*\)).*$/\1 \2/p'
}
