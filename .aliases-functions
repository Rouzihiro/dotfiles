# pms() {
#  pacman -Ss "$1" | GREP_COLORS='mt=01;31' grep --color=auto -i "$1"
# }

ali() {
  echo -e "\n\033[1;34m───────────[ Your Aliases ]───────────\033[0m\n"
  
  # List all aliases, exclude git-related ones and show in a neat format
  alias | grep -E "^[a-zA-Z_][a-zA-Z0-9_-]*=" | grep -v "^showalias=" | grep -v "git" | while IFS= read -r line; do
    # Extract alias name and value
    name="${line%%=*}"
    value="${line#*=}"
    
    # Remove leading/trailing single quotes if any
    value="${value#\'}"
    value="${value%\'}"
    
    # Display alias in cyan and gray colors, formatted
    printf " \033[1;36m%-20s\033[0m → \033[0;37m%s\033[0m\n" "$name" "$value"
  done | sort
  
  echo -e "\n\033[1;34m──────────────────────────────────────\033[0m\n"
}


show-alias() {
  echo -e "\n\033[1;34m───────────[ Your Aliases ]───────────\033[0m\n"
  alias | grep -E "^[a-zA-Z_][a-zA-Z0-9_-]*=" | grep -v "^showalias=" | while IFS= read -r line; do
    name="''${line%%=*}"
    value="''${line#*=}"
    value="''${value#\'}"
    value="''${value%\'}"
    printf " \033[1;36m%-20s\033[0m → \033[0;37m%s\033[0m\n" "$name" "$value"
  done | sort
  echo -e "\n\033[1;34m──────────────────────────────────────\033[0m\n"
}

# Extract any archive type
ex() {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)   tar xjf $1     ;;
            *.tar.gz)    tar xzf $1     ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar e $1     ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xf $1      ;;
            *.tbz2)      tar xjf $1     ;;
            *.tgz)       tar xzf $1     ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *.xz)        unxz $1        ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Quick note taking
note() {
    echo "$*" >> ~/Documents/notes
    echo "Note added: $*"
}


# View notes
notes() {
    if [ -f ~/Documents/notes ]; then
        if command -v bat >/dev/null 2>&1; then
            bat ~/Documents/notes
        else
            cat ~/Documents/notes
        fi
    else
        echo "No notes file found"
    fi
}


noter() {
    local file=~/Documents/notes
    [[ -f $file ]] || { echo "No notes file found"; return 1; }

    if command -v bat >/dev/null 2>&1; then
        bat -n --paging=never "$file"
    else
        cat -n "$file"
    fi

    echo -n "Enter line number to delete (or leave empty to cancel): "
    read lineno

    [[ $lineno =~ ^[0-9]+$ ]] || { echo "Cancelled"; return 1; }

    sed -i "${lineno}d" "$file"
    echo "Deleted line $lineno."
}

# Search history more efficiently  
hg() {
    history | grep "$1"
}

# Find and kill process by name
tko() {
    ps aux | grep "$1" | grep -v grep | awk '{print $2}' | xargs kill -9
}

# Create directory and cd into it
mkcd() {
    mkdir -p "$1" && cd "$1"
}

# Show directory size sorted
dirsize() {
    du -sh */ 2>/dev/null | sort -hr
}

# Quick file search
ff() {
    find . -type f -name "*$1*" 2>/dev/null
}

# Quick directory search  
fd() {
    find . -type d -name "*$1*" 2>/dev/null
}

fs() {
  find . -type f -exec grep --color=always --binary-files=without-match "$1" {} +
}

fzv() {
  while file=$(fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}'); do
    nvim "$file"
  done
}


